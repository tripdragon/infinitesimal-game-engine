<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Bleep bleep</title>
    <!-- <script src="mission1.js" type="module" defer></script> -->
    <!-- 
    python3 -m http.server 8001 
    
    this is just a canvas 2d app for pixel painting for now
    
    it shows how class Grid works
    
    localhost:8001/System1/Demos/paintgrid.html
    
    -->


    <style media="screen">
        *{
          margin: 0;
          padding: 0;
        }
        body{
          overflow: hidden;
        }
        
        /* ideally canvas gl is the bottom of the stack */
        #canvassss {
          z-index: -1;
          position: absolute;
        }
    </style>

    <style media="screen">
      /* #controls{
        position: absolute;
        top: 0px;
        left: 0px;
        z-index: 2;
        
        width: 100px;
        height: 100px;
        padding: 20px 0 0 20px;
      }

      #controls .add{
        
      } */
      
      #canvassss{
        /* background-color: orange; */
      }
      
      
      .button{
        width: 32px;
        height: 32px;
      }
      
      #controls222 {
        position: absolute;
        top: 0px;
        z-index: 1;
        
        width: 100%;
        height: 35px;
        padding: 20px 0 0 20px;
        
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        justify-content: center;
        align-content: stretch;
        align-items: flex-start;
      }

      #controls222 .button {
        order: 0;
        flex: 0 1 auto;
        align-self: auto;
        margin: 0 4px;
        font-size: 20px;
        
      }
      
      #ksdjfg{
        position: absolute;
        z-index: 12;
        bottom: 100px;
        left: 100px;
        background-color: white;
        width: 1px;
        height: 1px;
      }
      

    </style>
    
    <!-- idea is to inject here and clear when switching games -->
    <style id="gamestyles" media="screen">
      .fish {
        color: "pwgjpodg";
      }
      /* #canvassss{
        left: 25%;
        top: 25%;
      } */
    </style>
    
  </head>

  <body>
    <!-- <canvas id="canvassss" width="400" height="400"></canvas> -->

    <canvas id="canvassss" width="512" height="512"></canvas>
    
    

    <div id="gamespace"></div>
    <div id="bodyInjectionPointMain">
    </div>

    <script type="text/javascript">
        var APPPP;

    </script>

    <script type="module" type="text/javascript">
      // import AppMain from './AppMain.js';
      // APPPP = AppMain();

      import {Vector2} from '../Modules/Vector2.js';
      import {Grid} from '../Modules/Grid.js';
      
      import {keyboard} from '../Modules/Input/keyboard.js';
      
      const canvas = document.getElementById("canvassss");
      const canvasBuffer = document.createElement('canvas');
      canvasBuffer.width = 512;
      canvasBuffer.height = 512;
      const ctx = canvas.getContext("2d");
      const ctxBuffer = canvasBuffer.getContext("2d");
      
      window.canvasGG = canvas;
      
      
      var gamestyles = document.getElementById("gamestyles");
      var gg = document.getElementById("gamespace");
      // gg.innerHTML = "";
      
      // quick panel
      var panel = document.createElement('div');
      panel.id = "panel";
      panel.style.cssText = `
      position: absolute;
      ___overflow: hidden;
      top: 0px;
      right: 0px;
      z-index: 2;
      background: #00000022;
      width: 120px;
      min-height: 600px;
      padding: 20px 0 0 0;
      border-right : 1px #3c3c3c solid;
      /* flex box */
      display: flex;
      flex-direction: column;
      flex-wrap: nowrap;
      justify-content: flex-start;
      align-content: stretch;
      align-items: center;
      `;
      gg.appendChild(panel);

      
      var itemstyle = `
      #panel .item {
        background: white;
        width: 60px;
        height: 60px;
        margin-bottom: 12px;
        ____padding: 20px 0 0 0px;
        border : 1px white solid;
        border-radius: 12px;
        appearance: none;
        background-position: center center;
        background-size: cover;
        background-repeat: no-repeat;
        background-color: transparent;
        overflow: hidden;
        
        order: 0;
        flex: 0 1 auto;
        align-self: auto;
      }`;
      gamestyles.innerHTML += itemstyle;
      
      var colorPalete = document.createElement('div');
      colorPalete.classList.add("item");
      colorPalete.type = "box";
      // item.style.backgroundImage = "url(./Cast/Alien2.png)";
      colorPalete.style.backgroundColor = "#aaaaaa";
      panel.appendChild(colorPalete);
      // cache.push(colorPalete);
      
      
      
      
      
      
      
      var mouse = new Vector2();
      
      // var brushSize = 10;
      window.brushSize = 10;
      // window.brushColor = "c3ff00";
      window.brushColor = getRandomBrushColorApp();
      
      window.brushSizeUnit = 1;
      
      keyboard({
        
        "]": (ev) => {
          window.brushSizeUnit = 2;
        },
        "[": (ev) => {
          window.brushSizeUnit = 1;
        },
        
        "q": (ev) => {
          saveToFile();
        },
        
        
        " _up": (ev) => {
          // window.brushColor = ""+Math.random()*0xffffff;
          getRandomBrushColorApp();
        },
        
        
        "i_down": (ev) => {
          var gg = getColorAtMouse(mouse);
          setBrushColor(gg);
          console.log(gg);
        },
        
      

      });
      
      
      // https://stackoverflow.com/questions/6735470/get-pixel-color-from-canvas-on-mousemove
      function getColorAtMouse(mouse) {
        var p = ctx.getImageData(mouse.x, mouse.y, 1, 1).data; 
        var hex = ("000000" + rgbToHex(p[0], p[1], p[2])).slice(-6);
        // $('#status').html(coord + "<br>" + hex);
        // console.log("hex", hex);
        return hex;
      }
      function rgbToHex(r, g, b) {
          if (r > 255 || g > 255 || b > 255)
              throw "Invalid color component";
          return ((r << 16) | (g << 8) | b).toString(16);
      }
      
      
      
      function getRandomBrushColorApp() {
        window.brushColor = randomHexColor();
        console.log(window.brushColor);
        colorPalete.style.backgroundColor = "#"+window.brushColor;
      }
      
      function setBrushColor(color) {
        window.brushColor = color;
        console.log(window.brushColor);
        colorPalete.style.backgroundColor = "#"+window.brushColor;
      }
      
      
      // https://stackoverflow.com/questions/11112321/how-to-save-canvas-as-png-image
      function saveToFile() {
        // // var canvas = document.getElementById("alpha");
        // var dataURL = canvas.toDataURL("image/png");
        // var newTab = window.open('about:blank','image from canvas');
        // newTab.document.write("<img src='" + dataURL + "' alt='from canvas'/>");
        
        // canvas.toBlob(function(blob) {
        //     saveAs(blob, "pretty image.png");
        // });
        
        let downloadLink = document.createElement('a');
        downloadLink.setAttribute('download', 'CanvasAsImage.png');
        // let canvas = document.getElementById('myCanvas');
        let dataURL = canvas.toDataURL('image/png');
        let url = dataURL.replace(/^data:image\/png/,'data:application/octet-stream');
        downloadLink.setAttribute('href', url);
        downloadLink.click();
        
      }
      
      
      var IS_DOWN = false;
      // en do paint app clean line later
      var mPointDown = new Vector2();
      
      
      // if you dont get power of 2 numbers it draws borders at times
      // var sizeToFit = 512 / 9; //sizeToFit = Math.floor(sizeToFit);
      // var sizeToFit = 512 / Math.pow(2,4);
      var sizeToFit = 512 / Math.pow(2,5);
      var grid = new Grid(sizeToFit,1,1,null).computeRowsColumns(512, 512);
      
      
      // grid.snap(_this.system.pointer.x, _this.system.pointer.y).screenTo3D();
      // box2.x = grid.position3D.x;
      // box2.y = grid.position3D.y;
      
      
      
      function rColor(){
        return Math.floor(Math.random()*255);
      }
      
      function randomHexColor() {
        return Math.floor(Math.random()*16777215).toString(16);
      }
      
      // clear once
      function clear(){
        
        ctx.fillStyle = "rgba(0, 0, 0, 1)";
        ctx.fillRect(0, 0, canvasGG.width, canvasGG.height);
        
        for (var ii = 0; ii < grid.rows; ii++) {
          for (var mm = 0; mm < grid.columns; mm++) {
            ctx.fillStyle = `rgba(${rColor()}, ${rColor()}, ${rColor()}, 1)`;
            ctx.fillRect(ii*grid.size, mm*grid.size, grid.size, grid.size);
          }
        }
      }
      
      
      function showGridTopLeft(){
        for (var ii = 0; ii < grid.rows; ii++) {
          for (var mm = 0; mm < grid.columns; mm++) {
            ctx.fillStyle = `rgba(255,255,255, 1)`;
            var ssb = 10;
            ctx.fillRect(ii*grid.size, mm*grid.size, ssb, ssb);
          }
        }
      }
      
      function showGridCenter(){
        for (var ii = 0; ii < grid.rows+1; ii++) {
          for (var mm = 0; mm < grid.columns+1; mm++) {
            
            grid.snapAtRowCol(ii, mm);
            
            ctx.fillStyle = `rgba(255,255,255, 1)`;
            var ssb = 10;
            ctx.fillRect(grid.positionCenter.x- (ssb/2), grid.positionCenter.y - (ssb/2), ssb, ssb);
            // ctx.fillRect(grid.positionCenter.x, grid.positionCenter.y, ssb, ssb);
          }
        }
      }
      
      
      // var USE_DEBUGGER_Mouse = true;
      var USE_DEBUGGER_Mouse = false;
      
      
      function draw() {
        if (canvas.getContext) {


          // getColorAtMouse();

          if(USE_DEBUGGER_Mouse){
            // restore canvas
            ctx.drawImage(canvasBuffer, 0,0);
            
          }

          
          if(IS_DOWN){
            
            mPointDown.copy(mouse);
            
            // even odd brush sizes would have different snap and builder locations
            // so an even 2 would be a square
            
            // if brushsize 1
            grid.snap(mouse.x, mouse.y);
            
            // ctx.fillRect(mouse.x, mouse.y, brushSize, brushSize);
            // ctx.fillRect(grid.position.x - (grid.size / 2), grid.position.y - (grid.size / 2), grid.size, grid.size);
            // ctx.fillStyle = "rgba(0, 10, 100, 1)";
            ctx.fillStyle = "#"+window.brushColor;
            
            // ctx.fillRect(grid.positionCenter.x, grid.positionCenter.y, grid.size, grid.size);
            // ctx.fillRect(grid.position.x, grid.position.y, grid.size, grid.size);
            
            ctx.fillRect(grid.positionCenter.x - (grid.size/2), grid.positionCenter.y - (grid.size/2), grid.size, grid.size);
            
            // 
            // additional brushes, though a bit computational its narry much to recall
            // 
            if(brushSizeUnit === 2){
              var row = grid.indexRow; var col = grid.indexCol;
              
              grid.snapAtRowCol(row-1, grid.indexCol);
              ctx.fillRect(grid.positionCenter.x - (grid.size/2), grid.positionCenter.y - (grid.size/2), grid.size, grid.size);

              grid.snapAtRowCol(row+1, col);
              ctx.fillRect(grid.positionCenter.x - (grid.size/2), grid.positionCenter.y - (grid.size/2), grid.size, grid.size);
              
              grid.snapAtRowCol(row, col+1);
              ctx.fillRect(grid.positionCenter.x - (grid.size/2), grid.positionCenter.y - (grid.size/2), grid.size, grid.size);
              
              grid.snapAtRowCol(row, col-1);
              ctx.fillRect(grid.positionCenter.x - (grid.size/2), grid.positionCenter.y - (grid.size/2), grid.size, grid.size);
            }
            
          }
          
          // showGridTopLeft();
          // showGridCenter();
          
          
          if(USE_DEBUGGER_Mouse){
            // we need a little debugger moving box and not in dom element
            // so copy the canvar and redraw it at the start
            ctxBuffer.drawImage(canvas, 0,0);
            
            grid.snap(mouse.x, mouse.y);
            ctx.fillStyle = "rgba(10, 10, 10, 1)";
            // ctx.fillRect(grid.positionCenter.x, grid.positionCenter.y, grid.size, grid.size);
            // ctx.fillRect(grid.position.x, grid.position.y, 10, 10);
            // ctx.fillRect(grid.positionCenter.x, grid.positionCenter.y, 10, 10);
            ctx.fillRect(grid.positionCenter.x - 10/2, grid.positionCenter.y - 10/2, 10, 10);
            
            ctx.fillStyle = "rgba(0, 250, 240, 1)";
            // ctx.fillRect(grid.positionCenter.x, grid.positionCenter.y, grid.size, grid.size);
            ctx.fillRect(grid.position.x - 10/2, grid.position.y - 10/2, 10, 10);
            
          }
          
          
          
          
        }
      }
      

      var loopID;
      
      let loop = function(){

        loopID = requestAnimationFrame( loop.bind(this) );
        // console.log("popcorn");
        
        // this.time.now = Date.now();
        // this.time.delta = this.time.now - this.time.mTime;

        draw();
        
        // this.time.mTime = this.time.now;
      };

      function onPointerMove( event ) {
        
        mouse.x = event.clientX;
        mouse.y = event.clientY;
        
        // console.log(mouse);

      }
      
      function onPointerDown(ev){
        // debugger
        IS_DOWN = true;
      }
      function onPointerUp(ev){
        IS_DOWN = false;
      }
      
      
      
      // Setup
      
      clear();
      
      
      
      
      
      canvas.addEventListener( 'pointermove', onPointerMove.bind(this), true );
      canvas.addEventListener( 'pointerdown', onPointerDown.bind(this), true );
      canvas.addEventListener( 'pointerup', onPointerUp.bind(this), true );



      loop.call(this);
    

      
    </script>
  </body>
</html>
